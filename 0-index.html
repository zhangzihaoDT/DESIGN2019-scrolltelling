<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>凌空经济</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mapbox-gl@0.53.1/dist/mapbox-gl.css">
    <style>
        .upperLine {
          stroke: #103C9A;
          stroke-width: 2;
        }
        .lowerLine{
          stroke: #50A4E1;
          stroke-width: 2;
        }
        #small-multiples > div {
          display: inline-block;
          width: 240px;
          height: 185px;
        }
        .tooltip .x-axis .tick {
          display: none;
        }
        .x-axis .domain, .x-axis .tick path,
        .y-axis .domain, .y-axis .tick path {
          display: none;
        }
        .x-axis {
          height: 1.5em !important;
        }
        .x-axis-label{
          margin-top: 1em;
        }
        .gridline-x {
          stroke: #ccc;
          stroke-dasharray: 4,4
        }
        .point {
          fill: black;
        }
        .point text {
          text-anchor: middle;
          transform: translateY(-10px);
          font-size: 10px;
          stroke: none;
        }
        .bottom-handle {
          text-anchor: middle;
          font-size: 10px;
          transform: translateY(1.5em);
        }
        .top-handle {
          display: none;
        }
        .annotation-line line {
          display: none;
        }
  /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑ */
      .warp,#map{
        height: 50vh;
      }
      #container{
        width: 80vw;
        margin: 0 auto;
        padding-bottom: 10vh;
      }
      h1,p{
        padding: 0 20vw;
      }
      p{
        margin: 36px 0;
        border: 1px solid black;
        height: 30vh;
      }
      img{
        width: 100%;
      }
      .wrap{
        border: 1px solid black;
        height: 50vh;
      }
      #map.pin{
        width: 80vw;
        top: 0;
        position: fixed;
        z-index: -2;
      }
      .group{
        position: relative;
      }
      .bottom {
        position: absolute;
        bottom: 0;
        width: 100%;
      }
    </style>
</head>
<body>
    <div id="container">
        <div class="intro">
          <p>Lorem ipsum dolor sit amet consectetur adipisicing elit. Enim quod dolore corporis mollitia asperiores debitis ut modi tenetur ipsa iure? Dicta necessitatibus incidunt pariatur similique modi exercitationem est commodi doloremque.</p>
          <div>
            <img src="https://via.placeholder.com/1920x1080" alt="">
          </div>
        </div>
        <div class="artitle">
            <h1 class="title">标题</h1>
            <h2 class="author"></h2>
            <div></div>
            <div class="group">
                <p>地图初始化</p>
                <div class="wrap" id="mapbox-wrapper">
                    <div id="map"></div>
                </div>
                <p>scene01</p>
                <div class="subgroup" id = 'mapbox-sub'>
                  <div id="act-zero">
                      <p>10年吞吐量</p>
                  </div>
                  <div id="act-one">
                    <p>Part2.文字引入航线和中心度<br>全国机场中心度展现在地图上（颜色深浅区分）</p>
                    <p>TOP30中心度机场的区域分布<br>
                        鼠标滚动在地图上筛选出中心度top30的机场，出现区域边界，标注城市名。<br>
                        滚动出现城市排名的表格
                        </p>
                  </div>  
                  <div id="act-two">
                    <p>Lorem ipsum dolor sit amet consectetur adipisicing elit. Dolor, voluptates veniam consequuntur fugiat pariatur asperiores odit magnam commodi suscipit consequatur temporibus maiores vitae quos assumenda voluptatem mollitia voluptatum voluptate! Vel.</p>
                    <p>Lorem ipsum, dolor sit amet consectetur adipisicing elit. Cumque sequi reiciendis, accusamus veniam magnam officiis, animi harum accusantium quos eligendi doloribus quas voluptas tempore fugiat maxime velit veritatis quisquam error.</p>
                  </div>  
                   
                </div>
               
               <div class="wrap"></div>

            </div>
            <div class="group">
                
            </div>
            <div class="group">
                <div class="content">
                  <p>Lorem, ipsum dolor sit amet consectetur adipisicing elit. Doloremque dignissimos fugit tempora tempore quisquam possimus corrupti laborum ab, suscipit explicabo error soluta animi nulla recusandae optio omnis id natus consectetur?</p>
                  <p>Lorem ipsum dolor, sit amet consectetur adipisicing elit. Maiores eligendi, eius ad earum ipsam unde nam cumque nostrum nihil necessitatibus commodi doloremque velit, repudiandae laboriosam architecto sapiente laborum accusantium repellendus.</p>
                </div>
                <div id='small-multiples'></div>
            </div>
        </div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/scrollmagic@2.0.6/scrollmagic/uncompressed/ScrollMagic.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/scrollmagic@2.0.5/scrollmagic/minified/plugins/debug.addIndicators.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/deck.gl@7.0.0-rc.1/dist.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mapbox-gl@0.53.1/dist/mapbox-gl.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3@5.9.2/dist/d3.min.js"></script>
    <script src="//unpkg.com/d3fc@14.0.1"></script>
    <script>
    window.onload = function() {
        const map = document.querySelector("#map")
        // const groups = document.querySelectorAll(".group")
        const {MapboxLayer, ArcLayer, ScatterplotLayer} = deck;
        class ArcBrushingLayer extends ArcLayer {
        // custom shader with step function to create opacity gradient with colorA and colorB
        // More at https://thebookofshaders.com/05/
        getShaders() {
            return Object.assign({}, super.getShaders(), {
            inject: {
                'vs:#decl': `
                uniform float coef;
                `,
                'vs:#main-end': `
                if (coef > 0.0) {
                vec4 pct = vec4(segmentRatio);
                pct.a = step(coef, segmentRatio);
                vec4 colorA = instanceTargetColors;
                vec4 colorB = vec4(instanceTargetColors.r, instanceTargetColors.g, instanceTargetColors.b, 0.0);
                vec4 color = mix(colorA, colorB, pct) / 255.;
                vColor = color;
                }
                            `,
                            'fs:#main-start': `
                if (vColor.a == 0.0) discard;
                            `,
            },
            });
        }
        
        // overwrite draw fucntion
        draw(opts) {
            const {coef} = this.props;
            // add uniforms
            const uniforms = Object.assign({}, opts.uniforms, { coef });
            super.draw(Object.assign({}, opts, {uniforms}));
        }
    }
        const controller = new ScrollMagic.Controller();
    
        let timers = {}
        let indexes = {}

    // Get a mapbox API access token
    mapboxgl.accessToken = 'pk.eyJ1Ijoiemhhbmd6aWhhbyIsImEiOiJjamN6dDF1bzMwenphMzNuMjlqaG1vOTJlIn0.VdSfOPUC85YcWqs3LZeXmA';

    // Initialize mapbox map
    const mapbox = new mapboxgl.Map({
      container: 'map',
      center: [108,37],
      zoom: 3.2,
      pitch: 10,
      bearing: 0,
      renderWorldCopies: 1,
      style: "mapbox://styles/zhangzihao/cjvao5sd07yal1fqqcksteurk",
      scrollZoom: false
    });
    const DATA = d3.json("data/throughput.json");
    const DATA_AIR = d3.json('data/Airports-2018nodes.json').then(
        function(data){
            data.forEach(function(d) {
                d.position = eval(d.position)
            });
            return data;
        }
    );
    const DATA_PEK = d3.json('data/PEK_TSN_flights.json');
    const colorScale = d3.scaleLinear()
                          .domain([456,208034,612572,2263015,100983290])
                          .range([
                                  [130, 190,224,230],
                                  [57, 150,224,230],
                                  [12, 122,221,230],
                                  [7, 91,192,230],
                                  [16, 60,154,230]
                                ]);
    const radiusScale = d3.scaleLinear()
      .domain([456,100983290]).range([20000,200000]);
    const colorOrdinal = d3.scaleOrdinal()
      .domain(['PEK', 'TSN'])
      .range([[16,60,154,200], [80,164,225,200]]);
    const WIDTH_SCALE = d3.scaleLinear().domain([0,15000]).range([1, 10]);
    const CENTER_SCALE = d3.scaleLinear().domain([0,1]).range([20, 50000]);
    const layers = {
            "zero": [new MapboxLayer({
                id: "2015",
                type: ScatterplotLayer,
                data: DATA.then(function(data) {
                      data.forEach(function(d) {
                        d.position = eval(d.position);
                      });
                      console.log(data[0]);
                      return data.filter(function(d){
                        return d.year == 2015
                      })
                    }),
                stroked: true,
                lineWidthMinPixels: 2,
                getPosition: d => d.position,
                getRadius: d => radiusScale(d.passenger_throughput),
                getFillColor: d => colorScale(d.passenger_throughput),
                getLineColor: [0, 0, 0,100],
            }), new MapboxLayer({
                id: "2016",
                type: ScatterplotLayer,
                data: DATA.then(function(data) {
                      data.forEach(function(d) {
                        d.position = eval(d.position);
                      });
                      console.log(data[0]);
                      return data.filter(function(d){
                        return d.year == 2016
                      })
                    }),
                stroked: true,
                lineWidthMinPixels: 2,
                getPosition: d => d.position,
                getRadius: d => radiusScale(d.passenger_throughput),
                getFillColor: d => colorScale(d.passenger_throughput),
                getLineColor: [0, 0, 0,100],
            }), new MapboxLayer({
                id: "2017",
                type: ScatterplotLayer,
                data: DATA.then(function(data) {
                      data.forEach(function(d) {
                        d.position = eval(d.position);
                      });
                      console.log(data[0]);
                      return data.filter(function(d){
                        return d.year == 2017
                      })
                    }),
                stroked: true,
                lineWidthMinPixels: 2,
                getPosition: d => d.position,
                getRadius: d => radiusScale(d.passenger_throughput),
                getFillColor: d => colorScale(d.passenger_throughput),
                getLineColor: [0, 0, 0,100],
            })]
        }
        
    const scene1 = new ScrollMagic.Scene({ 
      triggerElement : document.querySelector('#mapbox-wrapper'),
      duration: document.querySelector('#mapbox-wrapper').scrollHeight+document.querySelector('#mapbox-sub').scrollHeight+36,
      triggerHook : 0,
    })
    .addTo(controller)
    .addIndicators()
    .on("enter",function(event){
      map.classList.remove('bottom');
      map.classList.add('pin');
    })
    .on("leave",function(event){
      console.log(event);
      if(event.scrollDirection === "REVERSE"){
        map.classList.remove('pin')
      }else if(event.scrollDirection === "FORWARD"){
        map.classList.replace('pin','bottom')
      }

    })

    const scence_zero = new ScrollMagic.Scene({
      triggerElement : document.querySelector('#act-zero'),
      duration: document.querySelector('#act-zero').scrollHeight,
      triggerHook : 0.25,
    }).addTo(controller)
    .addIndicators()
    .on("enter", function(event){
      indexes.act_zero = 0
            timers.act_zero = setInterval(function () {
                index = indexes.act_zero
                previous = layers.zero[index-1 < 0 ? layers.zero.length-1 : index-1].id
                if (mapbox.getLayer(previous)) {
                    mapbox.removeLayer(previous)
                }
                mapbox.addLayer(layers.zero[index])
                indexes.act_zero = (index + 1) % layers.zero.length
            }, 500)
    })
    .on("leave", function(event){
      if(timers.act_zero) {
                layers.zero.forEach(function (layer) {
                    if (mapbox.getLayer(layer.id)) {
                        mapbox.removeLayer(layer.id)
                    }
                })
                clearInterval(timers.act_zero)
            }
    })

    const airportsLayer = new MapboxLayer({
        id: 'deckgl-circle',
        type: ScatterplotLayer,
        data: DATA_AIR,
        getPosition: d => d.position,
        getFillColor: [0, 0, 0],
        getRadius: d => CENTER_SCALE(d.node_dc),
        opacity: 0.3
    });

    const scene_act_one = new ScrollMagic.Scene({
            triggerElement: document.querySelector('#act-one'),
            duration: document.querySelector('#act-one').scrollHeight,
            triggerHook: 0.25
        })
        .addTo(controller)
        .addIndicators()
        .on("enter", function (event) {
            mapbox.addLayer(airportsLayer)
        })
        .on("leave", function (event) {
            mapbox.removeLayer(airportsLayer.id)
        })
    
    const arcsLayer = new MapboxLayer({
       type: ArcBrushingLayer,
       id: `arcs`,
       data: DATA_PEK,
       opacity: 1,
       coef: 0.001,
       getSourcePosition: d => [d.departure_lng, d.departure_lat],
       getTargetPosition: d => [d.destination_lng, d.destination_lat],
       getSourceColor: d => colorOrdinal(d.departure),
       getTargetColor: d => colorOrdinal(d.departure),
       getWidth: d => WIDTH_SCALE(d.flights),
       getHeight:0.6,
       getTilt:5
    });

    const scene_act_two = new ScrollMagic.Scene({
            triggerElement: document.querySelector('#act-two'),
            duration: document.querySelector('#act-two').scrollHeight,
            triggerHook: 0.25
        })
        .addTo(controller)
        .addIndicators()
        .on("enter", function (event) {
            mapbox.addLayer(arcsLayer)
            mapbox.addLayer(airportsLayer)

            var coef = 0.001
            const animationInterval = setInterval(function () {
                coef += 0.005
                if (coef >= 1) {
                    clearInterval(animationInterval)
                }
                arcsLayer.setProps({coef})
            }, 10)
        })
        .on("leave", function (event) {
            mapbox.removeLayer(airportsLayer.id)
            mapbox.removeLayer(arcsLayer.id)
        })
    


    




  d3.csv('data/international_flights_top30.csv',(r) => ({
    category: r.airport_name,
    n: Number(r.international),
    n2: Number(r.domestic),
    year: Number(r.year),
    rank: Number(r.rank)
  }))
  .then((data) => {

    var nested = d3.nest()
    	.key(function(k) { return k.category; })
    	.entries(data);
    console.log(nested);

    nested.forEach(g => g.trackball = []);

    var color = d3.scaleLinear()
    .domain(fc.extentLinear()
    .accessors([d => d.rank])(data))
    .range(["#ffffff", "#000000"]);
    
    console.log(fc.extentLinear()
    .accessors([d => d.rank])(data));
    console.log(color(5));

    var yExtent = fc.extentLinear()
      .accessors([function(d) { return d.n+d.n2; }])
      .include([0]);
  
  	var xExtent = fc.extentLinear()
    	.accessors([function(d) { return d.year; }]);

    var area = fc.seriesSvgArea()
      .crossValue(function(d) { return d.year; })
      .mainValue(function(d) { return d.n; })
      .baseValue(function(d) { return d.n2; })
      .curve(d3.curveCatmullRom.alpha(1))
      .decorate(function(selection) {
        selection.enter().attr('fill',color(3))
      });
  
  	var upperLine = fc.seriesSvgLine()
      .crossValue(function(d) { return d.year; })
      .mainValue(function(d) { return d.n; })
      .decorate(function(selection) {
        selection.enter().classed('upperLine', true)
      });
    
    var lowerLine = fc.seriesSvgLine()
      .crossValue(function(d) { return d.year; })
      .mainValue(function(d) { return d.n2; })
      .decorate(function(selection) {
        selection.enter().classed('lowerLine', true)
      });;
  
  	var gridlines = fc.annotationSvgGridline()
    	.xTicks(0)
      .yTicks(3)
    
    var point = fc.seriesSvgPoint()
      .crossValue(d => d.year)
      .mainValue(d => d.value)
    	.size(15)
    	.decorate((selection) => {
        selection.enter()
        	.append('text');        
        selection.select('text')
        	.text(d => d.value)
      })
    
    var line = fc.annotationSvgLine()
    	.orient('vertical')
      .value(d => d.year)
    	.decorate((selection) => {
        selection.enter()
        	.select('.bottom-handle')
        	.append('text');        
        selection.select('.bottom-handle text')
        	.text(d => d.year)
      })
     
  
  	var multi = fc.seriesSvgMulti()
    	.series([area,  gridlines,lowerLine,upperLine,line,point])
      // .mapping(function(data, index, series) {
      //   return data.values;
      // });
      .mapping((data, index, series) => {
        switch (series[index]) {
        case point:            
        case line:
          return data.trackball;
        default:
          return data.values;
        }
      });
    
    var xScale = d3.scaleLinear();
    // create a chart
    var chart = fc.chartSvgCartesian(
        xScale,
        d3.scaleLinear())
      .yDomain(yExtent(data))
    	.xDomain(xExtent(data))
    	.xLabel(function(d) { return d.key; })
    	.yTicks(3)
    	.xTicks(4)
    	.xTickFormat(d3.format('0'))
      .yOrient('left')
    	.plotArea(multi);
      
    function render() {
      // render
    	var container = d3.select('#small-multiples')
      var update = container.selectAll('div.multiple')
        .data(nested);
      update.enter()
        .append('div')
      	.classed('multiple', true)
      	.merge(update)
        .call(chart)
        .classed('tooltip', function(d) { return d.trackball.length; });

      // add the pointer component to the plot-area, re-rendering
      // each time the event fires.
      var pointer = fc.pointer()
        .on('point', function(event) {
          if (event.length) {
            // determine the year
            var year = Math.round(xScale.invert(event[0].x));
            // add the point to each series
            nested.forEach(function(group) {
              var value = group.values.find(function(v) { return v.year === year; });
              group.trackball = [{
                year: year,
                value: value.n2,
                value2: value.n
              }];
            })
          } else {
            nested.forEach(function(g) {
              g.trackball = [];
            })
          }
          render();
        });

      d3.selectAll('#small-multiples .plot-area')
        .call(pointer);  
    }
  
  	render();
	});

  }
  </script>
</body>
</html>