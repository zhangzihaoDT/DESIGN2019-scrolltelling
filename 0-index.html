<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>凌空经济</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mapbox-gl@0.53.1/dist/mapbox-gl.css">
    <style>
        .upperLine {
          stroke: #103C9A;
          stroke-width: 2;
        }
        .lowerLine{
          stroke: #50A4E1;
          stroke-width: 2;
        }
        #small-multiples > div {
          display: inline-block;
          width: 240px;
          height: 185px;
        }
        .tooltip .x-axis .tick {
          display: none;
        }
        .x-axis .domain, .x-axis .tick path,
        .y-axis .domain, .y-axis .tick path {
          display: none;
        }
        .x-axis {
          height: 1.5em !important;
        }
        .x-axis-label{
          margin-top: 1em;
        }
        .gridline-x {
          stroke: #ccc;
          stroke-dasharray: 4,4
        }
        .point {
          fill: black;
        }
        .point text {
          text-anchor: middle;
          transform: translateY(-10px);
          font-size: 10px;
          stroke: none;
        }
        .bottom-handle {
          text-anchor: middle;
          font-size: 10px;
          transform: translateY(1.5em);
        }
        .top-handle {
          display: none;
        }
        .annotation-line line {
          display: none;
        }
  /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑ */
  #chart {
    width: 100%;
    height: 300px;
  }
  .open path {
    fill: lightblue;
    stroke: none;
  }
  .bar path {
    fill: #0173DC;
  }
  text.bar-label{
      font-size: 12px;
      fill: black;
  }
   /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑ */
      .warp,#map{
        height: 50vh;
      }
      #container{
        width: 80vw;
        margin: 0 auto;
        padding-bottom: 10vh;
      }
      h1,p{
        padding: 0 20vw;
      }
      p{
        margin: 0px 0;
        border: 1px solid black;
        height: 50vh;
      }
      img{
        width: 100%;
      }
      .wrap{
        border: 1px solid red;
        height: 50vh;
      }
      #map.pin{
        width: 80vw;
        top: 0;
        position: fixed;
        z-index: -2;
      }
      .group{
        position: relative;
      }
      .bottom {
        position: absolute;
        bottom: 0;
        width: 100%;
      }
    </style>
</head>
<body>
    <div id="container">
        <div class="intro">
          <p>Lorem ipsum dolor sit amet consectetur adipisicing elit. Enim quod dolore corporis mollitia asperiores debitis ut modi tenetur ipsa iure? Dicta necessitatibus incidunt pariatur similique modi exercitationem est commodi doloremque.</p>
          <div>
            <img src="https://via.placeholder.com/1920x1080" alt="">
          </div>
        </div>
        <div class="artitle">
            <h1 class="title">Part1.开头文字进入正文，提到吞吐量</h1>
            <h2 class="author"></h2>
            <div></div>
            <div class="group">
                <p>地图初始化</p>
                <div class="wrap" id="mapbox-wrapper">
                    <div id="map"></div>
                </div>
                <p class="opening">scene01</p>
                <div class="subgroup" id = 'mapbox-sub'>
                  <div id="act-zero">
                      <p>10年吞吐量</p>
                  </div>
                  <div id="act-one">
                    <p>Part2.文字引入航线和中心度<br>全国机场中心度展现在地图上（颜色深浅区分）</p>
                  </div>  
                  <div id="act-two">
                    <p>TOP30中心度机场的区域分布</p>
                  </div>  
                  <div id="act-three">
                    <p>区域最强机场的辐射范围</p>
                    <p>华北：地图展现北京首都机场和ta联系最紧密的top10机场航线<br>
                      华北区域的边界线展现出来，标注城市名；</p>
                  </div> 
                </div>
               
               <div class="wrap"></div>

            </div>
            <div class="group">
              <p>Lorem ipsum dolor sit amet consectetur adipisicing elit. Recusandae aspernatur, dolore molestias iusto cupiditate aliquid fugiat atque? Nisi sequi incidunt reiciendis consequuntur explicabo! Minima aperiam placeat sequi maiores, dolore ipsum.</p>
              <div id='chart'>
                <d3fc-group id='group' style='display: flex; height: 100%; width: 100%; flex-direction: column' auto-resize>
                  <div style='flex: 1; display: flex; flex-direction: column'>
                      <div style='flex: 1; display: flex; flex-direction: row'>
                          <d3fc-svg class='close-axis' style='width: 3em'></d3fc-svg>
                          <d3fc-svg class='plot-area' style='flex: 1; overflow: hidden'></d3fc-svg>
                          <d3fc-svg class='open-axis' style='width: 3em'></d3fc-svg>
                      </div>
                      <d3fc-svg class='x-axis' style='height: 2em; margin-left: 3em; margin-right: 3em'></d3fc-svg>
                  </div>
                </d3fc-group>
              </div>
            </div>
            <div class="group">
                <div class="content">
                  <p>Lorem, ipsum dolor sit amet consectetur adipisicing elit. Doloremque dignissimos fugit tempora tempore quisquam possimus corrupti laborum ab, suscipit explicabo error soluta animi nulla recusandae optio omnis id natus consectetur?</p>
                  <p>Lorem ipsum dolor, sit amet consectetur adipisicing elit. Maiores eligendi, eius ad earum ipsam unde nam cumque nostrum nihil necessitatibus commodi doloremque velit, repudiandae laboriosam architecto sapiente laborum accusantium repellendus.</p>
                </div>
                <div id='small-multiples'></div>
            </div>
        </div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/scrollmagic@2.0.6/scrollmagic/uncompressed/ScrollMagic.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/scrollmagic@2.0.5/scrollmagic/minified/plugins/debug.addIndicators.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/deck.gl@7.0.0-rc.1/dist.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mapbox-gl@0.53.1/dist/mapbox-gl.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3@5.9.2/dist/d3.min.js"></script>
    <script src="//unpkg.com/d3fc@14.0.1"></script>
    <script>
    window.onload = function() {
        const map = document.querySelector("#map")
        // const groups = document.querySelectorAll(".group")
        const {MapboxLayer, ArcLayer, ScatterplotLayer,GeoJsonLayer} = deck;
        class ArcBrushingLayer extends ArcLayer {
        // custom shader with step function to create opacity gradient with colorA and colorB
        // More at https://thebookofshaders.com/05/
        getShaders() {
            return Object.assign({}, super.getShaders(), {
            inject: {
                'vs:#decl': `
                uniform float coef;
                `,
                'vs:#main-end': `
                if (coef > 0.0) {
                vec4 pct = vec4(segmentRatio);
                pct.a = step(coef, segmentRatio);
                vec4 colorA = instanceTargetColors;
                vec4 colorB = vec4(instanceTargetColors.r, instanceTargetColors.g, instanceTargetColors.b, 0.0);
                vec4 color = mix(colorA, colorB, pct) / 255.;
                vColor = color;
                }
                            `,
                            'fs:#main-start': `
                if (vColor.a == 0.0) discard;
                            `,
            },
            });
        }
        
        // overwrite draw fucntion
        draw(opts) {
            const {coef} = this.props;
            // add uniforms
            const uniforms = Object.assign({}, opts.uniforms, { coef });
            super.draw(Object.assign({}, opts, {uniforms}));
        }
    }
        const controller = new ScrollMagic.Controller();
    
        let timers = {}
        let indexes = {}

    // Get a mapbox API access token
    mapboxgl.accessToken = 'pk.eyJ1Ijoiemhhbmd6aWhhbyIsImEiOiJjamN6dDF1bzMwenphMzNuMjlqaG1vOTJlIn0.VdSfOPUC85YcWqs3LZeXmA';

    // Initialize mapbox map
    const mapbox = new mapboxgl.Map({
      container: 'map',
      center: [108,37],
      zoom: 3.2,
      pitch: 20,
      bearing: 0,
      renderWorldCopies: 1,
      style: "mapbox://styles/zhangzihao/cjvao5sd07yal1fqqcksteurk",
      scrollZoom: false
    });
    const DATA = d3.json("data/throughput.json");
    const DATA_AREA = d3.json('data/china.json');
    const DATA_AIR = d3.json('data/Airports-2018nodes.json').then(
        function(data){
            data.forEach(function(d) {
                d.position = eval(d.position)
            });
            return data;
        }
    );
    const DATA_FLY = d3.json('data/regional_airport_top10.json');
    console.log(DATA_AREA);
    const colorScale = d3.scaleLinear()
                          .domain([456,208034,612572,2263015,100983290])
                          .range([[130, 190,224,230],[57, 150,224,230],[12, 122,221,230], [7, 91,192,230],[16, 60,154,230]]);
    const radiusScale = d3.scaleLinear()
      .domain([456,100983290]).range([20000,200000]);
    const colorOrdinal = d3.scaleOrdinal()
      .domain(['PEK', 'TSN'])
      .range([[16,60,154,200], [80,164,225,200]]);
    const WIDTH_SCALE = d3.scaleLinear().domain([4000,30000]).range([1, 10]);
    const CENTER_SCALE = d3.scaleLinear().domain([0,1]).range([600, 60000]);
    const COLOR_SCALE = d3.scaleLinear()
                          .domain([0,0.5,1]).range([[130, 190,224],[12, 122,221],[16, 60,154]]);;
    const layers = {
            "zero": [new MapboxLayer({
                id: "2015",
                type: ScatterplotLayer,
                data: DATA.then(function(data) {
                      data.forEach(function(d) {
                        d.position = eval(d.position);
                      });
                      console.log(data[0]);
                      return data.filter(function(d){
                        return d.year == 2015
                      })
                    }),
                stroked: true,
                lineWidthMinPixels: 2,
                getPosition: d => d.position,
                getRadius: d => radiusScale(d.passenger_throughput),
                getFillColor: d => colorScale(d.passenger_throughput),
                getLineColor: [0, 0, 0,100],
            }), new MapboxLayer({
                id: "2016",
                type: ScatterplotLayer,
                data: DATA.then(function(data) {
                      data.forEach(function(d) {
                        d.position = eval(d.position);
                      });
                      console.log(data[0]);
                      return data.filter(function(d){
                        return d.year == 2016
                      })
                    }),
                stroked: true,
                lineWidthMinPixels: 2,
                getPosition: d => d.position,
                getRadius: d => radiusScale(d.passenger_throughput),
                getFillColor: d => colorScale(d.passenger_throughput),
                getLineColor: [0, 0, 0,100],
            }), new MapboxLayer({
                id: "2017",
                type: ScatterplotLayer,
                data: DATA.then(function(data) {
                      data.forEach(function(d) {
                        d.position = eval(d.position);
                      });
                      console.log(data[0]);
                      return data.filter(function(d){
                        return d.year == 2017
                      })
                    }),
                stroked: true,
                lineWidthMinPixels: 2,
                getPosition: d => d.position,
                getRadius: d => radiusScale(d.passenger_throughput),
                getFillColor: d => colorScale(d.passenger_throughput),
                getLineColor: [0, 0, 0,100],
            })]
        }
        
    const scene1 = new ScrollMagic.Scene({ 
      triggerElement : document.querySelector('#mapbox-wrapper'),
      duration: document.querySelector('#mapbox-wrapper').scrollHeight+document.querySelector('#mapbox-sub').scrollHeight+36,
      triggerHook : 0,
    })
    .addTo(controller)
    .addIndicators()
    .on("enter",function(event){
      map.classList.remove('bottom');
      map.classList.add('pin');
    })
    .on("leave",function(event){
      console.log(event);
      if(event.scrollDirection === "REVERSE"){
        map.classList.remove('pin')
      }else if(event.scrollDirection === "FORWARD"){
        map.classList.replace('pin','bottom')
      }

    })

    const scence_zero = new ScrollMagic.Scene({
      triggerElement : document.querySelector('#act-zero'),
      duration: document.querySelector('#act-zero').scrollHeight,
      triggerHook : 0.25,
    }).addTo(controller)
    .addIndicators()
    .on("enter", function(event){
      indexes.act_zero = 0
            timers.act_zero = setInterval(function () {
                index = indexes.act_zero
                previous = layers.zero[index-1 < 0 ? layers.zero.length-1 : index-1].id
                if (mapbox.getLayer(previous)) {
                    mapbox.removeLayer(previous)
                }
                mapbox.addLayer(layers.zero[index])
                indexes.act_zero = (index + 1) % layers.zero.length
            }, 500)
    })
    .on("leave", function(event){
      if(timers.act_zero) {
                layers.zero.forEach(function (layer) {
                    if (mapbox.getLayer(layer.id)) {
                        mapbox.removeLayer(layer.id)
                    }
                })
                clearInterval(timers.act_zero)
            }
    })

    const airportsLayer = new MapboxLayer({
        id: 'all-airports',
        type: ScatterplotLayer,
        data: DATA_AIR,
        getPosition: d => d.position,
        getFillColor: d => COLOR_SCALE(d.node_dc),
        getRadius: d => CENTER_SCALE(d.node_dc),
        opacity: 0.3,
        lineWidthMinPixels: 2,
        getLineColor: [0, 0, 0,100]
    });

    const scene_act_one = new ScrollMagic.Scene({
            triggerElement: document.querySelector('#act-one'),
            duration: document.querySelector('#act-one').scrollHeight,
            triggerHook: 0.25
        })
        .addTo(controller)
        .addIndicators()
        .on("enter", function (event) {
            mapbox.addLayer(airportsLayer)
        })
        .on("leave", function (event) {
            mapbox.removeLayer(airportsLayer.id)
        })
    
    const top30Layer = new MapboxLayer({
      type: GeoJsonLayer,
      id: 'geojson-layer',
      data:DATA_AREA,
      stroked: true,
      // filled: true,
      // extruded: true,
      lineWidthScale: 20,
      lineWidthMinPixels: 2,
      getFillColor: [0, 0, 0, 20],
      getLineColor: [0, 0, 0, 20],
      getRadius: 100,
      getLineWidth: 1,
      getElevation: 30,
    })
    
    const scene_act_two = new ScrollMagic.Scene({
            triggerElement: document.querySelector('#act-two'),
            duration: document.querySelector('#act-two').scrollHeight,
            triggerHook: 0.25
        })
        .addTo(controller)
        .addIndicators()
        .on("enter", function (event) {
            mapbox.addLayer(top30Layer)
            mapbox.addLayer(airportsLayer)
        })
        .on("leave", function (event) {
            mapbox.removeLayer(airportsLayer.id)
            mapbox.removeLayer(top30Layer.id)
        })

    const arcsLayer_PEK = new MapboxLayer({
       type: ArcBrushingLayer,
       id: `arcs_PEK`,
       data: DATA_FLY.then(function(data){
        return data.filter(function(d){
          return d.code_1 === 'PEK'
        })
       }),
       opacity: 1,
       coef: 0.001,
       getSourcePosition: d => [d.lng_1, d.lat_1],
       getTargetPosition: d => [d.lng_2, d.lat_2],
       getSourceColor: d => [16,60,154,200],
       getTargetColor: d => [16,60,154,200],
       getWidth: d => WIDTH_SCALE(d.total_flights),
       getHeight:0.8,
       getTilt:0
    });

    const huabeiLayer = new MapboxLayer({
      type: GeoJsonLayer,
      id: 'geojson-layer-huabei',
      data:DATA_AREA.then(function(data){
        console.log('data --', data)
        console.log('type data.features. ', typeof data.features)
        return data.features.filter(function(d){
          console.log('d ', d)
          return d.id === 0
        })
      }),
      stroked: true,
      // filled: true,
      // extruded: true,
      lineWidthScale: 20,
      lineWidthMinPixels: 2,
      getFillColor: [0, 0, 0, 20],
      getLineColor: [0, 0, 0, 20],
      getRadius: 100,
      getLineWidth: 1,
      getElevation: 30,
    })

    const scene_act_three = new ScrollMagic.Scene({
            triggerElement: document.querySelector('#act-three'),
            duration: document.querySelector('#act-three').scrollHeight,
            triggerHook: 0.25
        })
        .addTo(controller)
        .addIndicators()
        .on("enter", function (event) {
            mapbox.addLayer(arcsLayer_PEK)
            mapbox.addLayer(huabeiLayer)
            var coef = 0.001
            const animationInterval = setInterval(function () {
                coef += 0.005
                if (coef >= 1) {
                    clearInterval(animationInterval)
                }
                arcsLayer_PEK.setProps({coef})
            }, 10)
        })
        .on("leave", function (event) {
            mapbox.removeLayer(arcsLayer_PEK.id)
            mapbox.addLayer(huabeiLayer.id)
        })
    


    




  d3.csv('data/international_flights_top30.csv',(r) => ({
    category: r.airport_name,
    n: Number(r.international),
    n2: Number(r.domestic),
    year: Number(r.year),
    rank: Number(r.rank)
  }))
  .then((data) => {

    var nested = d3.nest()
    	.key(function(k) { return k.category; })
    	.entries(data);
    console.log(nested);

    nested.forEach(g => g.trackball = []);

    var color = d3.scaleLinear()
    .domain(fc.extentLinear()
    .accessors([d => d.rank])(data))
    .range(["#ffffff", "#000000"]);
    
    console.log(fc.extentLinear()
    .accessors([d => d.rank])(data));
    console.log(color(5));

    var yExtent = fc.extentLinear()
      .accessors([function(d) { return d.n+d.n2; }])
      .include([0]);
  
  	var xExtent = fc.extentLinear()
    	.accessors([function(d) { return d.year; }]);

    var area = fc.seriesSvgArea()
      .crossValue(function(d) { return d.year; })
      .mainValue(function(d) { return d.n; })
      .baseValue(function(d) { return d.n2; })
      .curve(d3.curveCatmullRom.alpha(1))
      .decorate(function(selection) {
        selection.enter().attr('fill',color(3))
      });
  
  	var upperLine = fc.seriesSvgLine()
      .crossValue(function(d) { return d.year; })
      .mainValue(function(d) { return d.n; })
      .decorate(function(selection) {
        selection.enter().classed('upperLine', true)
      });
    
    var lowerLine = fc.seriesSvgLine()
      .crossValue(function(d) { return d.year; })
      .mainValue(function(d) { return d.n2; })
      .decorate(function(selection) {
        selection.enter().classed('lowerLine', true)
      });;
  
  	var gridlines = fc.annotationSvgGridline()
    	.xTicks(0)
      .yTicks(3)
    
    var point = fc.seriesSvgPoint()
      .crossValue(d => d.year)
      .mainValue(d => d.value)
    	.size(15)
    	.decorate((selection) => {
        selection.enter()
        	.append('text');        
        selection.select('text')
        	.text(d => d.value)
      })
    
    var line = fc.annotationSvgLine()
    	.orient('vertical')
      .value(d => d.year)
    	.decorate((selection) => {
        selection.enter()
        	.select('.bottom-handle')
        	.append('text');        
        selection.select('.bottom-handle text')
        	.text(d => d.year)
      })
     
  
  	var multi = fc.seriesSvgMulti()
    	.series([area,  gridlines,lowerLine,upperLine,line,point])
      // .mapping(function(data, index, series) {
      //   return data.values;
      // });
      .mapping((data, index, series) => {
        switch (series[index]) {
        case point:            
        case line:
          return data.trackball;
        default:
          return data.values;
        }
      });
    
    var xScale = d3.scaleLinear();
    // create a chart
    var chart = fc.chartSvgCartesian(
        xScale,
        d3.scaleLinear())
      .yDomain(yExtent(data))
    	.xDomain(xExtent(data))
    	.xLabel(function(d) { return d.key; })
    	.yTicks(3)
    	.xTicks(4)
    	.xTickFormat(d3.format('0'))
      .yOrient('left')
    	.plotArea(multi);
      
    function render() {
      // render
    	var container = d3.select('#small-multiples')
      var update = container.selectAll('div.multiple')
        .data(nested);
      update.enter()
        .append('div')
      	.classed('multiple', true)
      	.merge(update)
        .call(chart)
        .classed('tooltip', function(d) { return d.trackball.length; });

      // add the pointer component to the plot-area, re-rendering
      // each time the event fires.
      var pointer = fc.pointer()
        .on('point', function(event) {
          if (event.length) {
            // determine the year
            var year = Math.round(xScale.invert(event[0].x));
            // add the point to each series
            nested.forEach(function(group) {
              var value = group.values.find(function(v) { return v.year === year; });
              group.trackball = [{
                year: year,
                value: value.n2,
                value2: value.n
              }];
            })
          } else {
            nested.forEach(function(g) {
              g.trackball = [];
            })
          }
          render();
        });

      d3.selectAll('#small-multiples .plot-area')
        .call(pointer);  
    }
  
  	render();
	});

  }

  d3.csv('data/prices.csv').then(
          function(data){
              data.forEach(function(d) {
                  d.date = d.date;
                  d.close = +d.close;
                  d.open = +d.open;
              });
              return data;
          }
  ).then(function(data){
    // components for computing the data extent
    var closeExtent = fc.extentLinear().include([0])
    .pad([0, 0.4])
    .accessors([
        function(d) { return d.close; }
    ]);
    var openExtent = fc.extentLinear().include([0])
    .pad([0, 0.2])
    .accessors([
        function(d) { return d.open; }
    ]);

    // scales
    var openScale = d3.scaleLinear();
    var closeScale = d3.scaleLinear();
    var xScale = d3.scaleBand()
		.padding(0.5)
		.align(0.5);

    // axes
    var xAxis = fc.axisBottom()
    .scale(xScale).tickPadding(5);
    var openAxis = fc.axisRight()
    .scale(openScale);
    var closeAxis = fc.axisLeft()
    .scale(closeScale);

    // series
    var closeSeries = fc.seriesSvgPoint()
    .size(30)
    .crossValue(function(d) { return d.date; })
    .mainValue(function(d) { return d.close; })
    .xScale(xScale)
    .yScale(closeScale);

    var openSeries = fc.autoBandwidth(fc.seriesSvgBar())
    .crossValue(function(d) { return d.date; })
    // .align('left')
    .mainValue(function(d) { return d.open; })
    .xScale(xScale)
    .yScale(openScale)
    .decorate(function(selection) {
        // add labels
        selection.enter()
            .append('text')
            .attr('class', 'bar-label')
            .attr('transform', 'translate(-10, -15)')
            .text(d => d3.format('.0%')(d.open));
    });

    // handle the 'draw' event from the d3fc-svg and d3fc-group elements
    d3.select('.close-axis')
    .on('draw', function(d, i, nodes) {
        d3.select(nodes[i])
        .select('svg')
        .attr('viewBox', `${-event.detail.width} 0 ${event.detail.width} ${event.detail.height}`)
        .call(closeAxis);
    });

    d3.select('.open-axis')
    .on('draw', function(d, i, nodes) {
        d3.select(nodes[i])
        .select('svg')
        .call(openAxis);
    });

    d3.select('.x-axis')
    .on('draw', function(d, i, nodes) {
        d3.select(nodes[i])
        .select('svg')
        .attr("transform", "translate(-5,0)")
        .call(xAxis);
    });

    // handle the plot area measure event in order to compute the scale ranges
    d3.select('.plot-area')
    .on('measure', function() {
        xScale.range([0, event.detail.width]);
        openScale.range([event.detail.height, 0]);
        closeScale.range([event.detail.height, 0]);
    })

    // use the data-join component in order to create the inner 'g' elements. This ensures
    // that the elements are only created once.
    var closeJoin = fc.dataJoin('g', 'close');
    var openJoin = fc.dataJoin('g', 'open');
  // set the domain
  openScale.domain(openExtent(data));
  closeScale.domain(closeExtent(data));
  xScale.domain(data.map(d => d.date));

  // render the chart
  d3.select('.plot-area')
    .on('draw', function(d, i, nodes) {
      var svg = d3.select(nodes[i])
        .select('svg');
      closeJoin(svg, [data])
        .call(openSeries);
      openJoin(svg, [data])
        .call(closeSeries);
    });

  d3.select('#group')
      .node()
      .requestRedraw();       
});
  </script>
</body>
</html>